<?php

/**
 * @file
 * Contains commerce_bulk.module.
 */

use Drupal\Core\Form\FormStateInterface;
use Drupal\commerce_bulk\Entity\BulkProductVariation;
use Drupal\Core\StringTranslation\TranslatableMarkup;
use Drupal\commerce_product\Entity\ProductAttributeInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\commerce_bulk\BulkEntityTypeInfo;
use Drupal\commerce_product\Entity\ProductAttribute;
use Drupal\commerce_product\Entity\ProductAttributeValueInterface;
use Drupal\taxonomy\TermInterface;
use Drupal\taxonomy\VocabularyInterface;

/**
 * Implements hook_commerce_bulk_variation_alter().
 */
function commerce_bulk_commerce_bulk_variation_alter(array &$variations, $data = '', $product_type = '') {
  if ($product_type == 'my_product_type') {
    // Optionally, decode 'json' or 'xml' data passed on the VBO action
    // configuration page and use that to alter variations.
    // $array_data = \Drupal::service('serializer')->decode($data, 'json');
    foreach ($variations as $variation) {
      // Enable core `Serialization' module to decode the string $data.
      // Do something and save variation.
      // The parent product will be saved later by the hook caller.
      // $variation->save();
    }
  }
}

/**
 * Implements hook_TYPE_alter().
 *
 * Allows to alter auto SKU generated by the commerce_bulk.variations_creator
 * service before saving it on a product variation. Note that SKU must be unique
 * across entire Drupal site.
 *
 * @see \Drupal\commerce_bulk\BulkVariationsCreator::getAutoSku()
 */
function commerce_bulk_bulk_creator_sku_alter(&$sku, $settings, $variation) {
  // Do required changes using variables passed.
  // $prefix = $settings['prefix'];
  // $suffix = $settings['suffix'];
  // $sku = "{$prefix}_ALTERED_SKU_{$suffix}";
  // Note that return value is not required as the $sku is passed as reference.
}

/**
 * Implements hook_TYPE_alter().
 *
 * Allows to alter an attribute value fields data.
 *
 * @see \Drupal\commerce_bulk\Plugin\Action\AttributeValueName::submitConfigurationForm()
 */
function commerce_bulk_commerce_bulk_attribute_value_alter(ProductAttributeValueInterface &$attribute, &$name, $data) {
  // Do required changes optionally using $data passed.
  // Enable core `Serialization' module to decode 'json' or 'xml' data passed on
  // the VBO action configuration page and use that to alter $attribute / $name:
  // static $array_data;
  // $array_data = $array_data ?: \Drupal::service('serializer')->decode($data, 'json');
  // Note that $attribute will be saved later by the hook caller.
}

/**
 * Implements hook_TYPE_alter().
 *
 * Allows to alter an taxonomy term fields data.
 *
 * @see \Drupal\commerce_bulk\Plugin\Action\TermDuplicate::submitConfigurationForm()
 */
function commerce_bulk_commerce_bulk_term_new_alter(TermInterface &$term, &$name, $data) {
  // Do required changes optionally using $data passed.
  // Enable core `Serialization' module to decode 'json' or 'xml' data passed on
  // the VBO action configuration page and use that to alter $term / $name:
  // static $array_data;
  // $array_data = $array_data ?: \Drupal::service('serializer')->decode($data, 'json');
  // Note that $term will be saved later by the hook caller.
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function commerce_bulk_form_views_form_commerce_bulk_variations_tab_commerce_bulk_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (!($product = \Drupal::request()->attributes->get('commerce_product'))) {
    return;
  }
  $creator = \Drupal::service('commerce_bulk.variations_creator');
  $messenger = \Drupal::messenger();
  $variations = $product->getVariations();
  $created = count($variations);
  $variations = $product->getVariations() ?: [$creator->getProductVariation($product)];
  $all = $creator->getNotUsedAttributesCombination($variations);
  extract($all);
  $form['#markup'] = new TranslatableMarkup('<div><h3>Variations:</h3><ul><li>Maximum: @count</li><li>Created: <span style="font-weight:bolder;color:red;">@created</span></li><li>Not used: @not_used</li></ul></div>', [
    '@count' => $count,
    '@created' => $created,
    '@not_used' => $count - $created,
  ]);
  if ($duplicated) {
    $placeholders = [
      '@variations' => $duplicated > 1 ? new TranslatableMarkup('variations') : new TranslatableMarkup('variation'),
      '@duplicated' => $duplicated,
      '@labels' => $all['duplications_list'],
    ];
    $warning = new TranslatableMarkup('You have @duplicated @variations duplicated: @labels', $placeholders);
    $messenger->addMessage($warning, 'warning');
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function commerce_bulk_form_views_form_commerce_bulk_attributes_attribute_page_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (!($id = \Drupal::request()->attributes->get('commerce_product_attribute'))
    || !$attribute = ProductAttribute::load($id)
  ) {
    return;
  }
  $form['#markup'] = new TranslatableMarkup('<h3>Attribute values: <span style="color:red;">@count</span></h3>', [
    '@count' => count($attribute->getValues()),
  ]);
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function commerce_bulk_form_views_form_commerce_bulk_taxonomy_vocabulary_page_alter(&$form, FormStateInterface $form_state, $form_id) {
  if ($vid = \Drupal::request()->get('taxonomy_vocabulary')) {
    $storage = \Drupal::entityTypeManager()->getStorage('taxonomy_term');
    $form['#markup'] = new TranslatableMarkup('<h3>Number of terms: <span style="color:red;">@count</span></h3>', [
      '@count' => count($storage->loadByProperties(['vid' => $vid])),
    ]);
  }
}

/**
 * Implements hook_entity_type_alter().
 */
function commerce_bulk_entity_type_alter(array &$entity_types) {
  $entity_types['commerce_product_variation']->setClass(BulkProductVariation::class);
}

/**
 * Implements hook_entity_operation().
 */
function commerce_bulk_entity_operation(EntityInterface $entity) {
  if ($entity instanceof ProductAttributeInterface ||
      $entity instanceof VocabularyInterface) {
    return \Drupal::service('class_resolver')
      ->getInstanceFromDefinition(BulkEntityTypeInfo::class)
      ->entityOperation($entity);
  }
}
